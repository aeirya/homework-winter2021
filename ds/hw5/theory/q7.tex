%کپی شده و ادیت نشده%

%\begin{latin}
%\begin{codebox}
%	\Procname{$\proc{}$}
%	
%\end{codebox}	
%\end{latin}


یک درخت 
trie 
می‌سازیم با این تفاوت
که برای بچه‌های آن ترتیب 
قائل می‌شویم.
به عبارتی
اگر دو کلمه 
xb 
و 
xa 
را در آن اضافه کنیم درخت به یاد 
داشته باشد که بین بچه های 
x 
اول 
b 
بوده است و سپس 
a
.
حال تمام رشته ها را به این درخت اضافه می‌کنیم.
.

همچنین یک گراف جهت‌دار با H راس 
( هر راس نماینده یک حرف الفبا) 
می‌سازیم
.

حال بر روی این درخت ترای پیمایش می‌کنیم
(مثلا 
BFS
)
و برای هر گره‌که به آن می‌رویم این عملیات را انجام می‌دهیم
:

برای فرزندان گره مورد نظر:
نقاط متناظر حروف فرزاندان 
$i$ 
و
$i+1$
را در گراف ساخته شده پیدا می‌کنیم 
و
از فرزند چپی (کوچک‌تر) به راستی یک یال رسم می‌کنیم
.
این کار را برای هر دو جفت فرزند مجاور این گره انجام می‌دهیم.

مفهوم
 پشت کاری که انجام دادیم این است که اگر دو
 رشته تا تعدادی حرف مشابه باشند٫ 
 اولین حرفی که متفاوت هستند 
 به ما این آگاهی را می‌دهد 
 که آن حرف رشته کوچیک تر از حرف هم اندیسش در رشته بزرگ‌تر کوچک تر است
 و
  این روابط کوچک‌تری را در گراف می‌توان به راحتی نگهداری کرد.

همچنین نیازی نیست تمام رشته ها را دو به دو بررسی کرد چون کوچک‌تری خاصیت تعدی دارد و کافی است رشته های مجاور را مقایسه کرد.

  در نهایت بر روی گراف ساخته شده از ترتیب‌های جزئی در زمان 
O(?????????)
   توپولوژیکال سورت انجام می‌دهیم 
  و به یکی از جواب‌های درست مسئله دست میابیم
  .

  اگر در گراف ساخته شده دور وجود داشته باشد برای این مسئله جوابی وجود ندارد 
  و می‌توان در زمان ثابت 
  بر روی این گراف با راس‌های مشخص به دنبال دور گشت
  (با پیدا کردن یال های عقب گرد در 
  DFS
  ) .
  چرا که ارزش ترتیبی هیچ دو حرفی با هم مساوی نیست 
  و 
  از دور می‌توان نتیجه گرفت تمام حروف روی دور با هم مساوی و هم ارزش هستند
  .


  برای سورت توپولوژیک هم 
  به این شکل عمل می‌کنیم که الگوریتم 
  DFS 
  میزنیم اما با این فرق که 
  یک استک داریم و برای هر راسی 
  که به آن می‌رویم ابتدا 
  به طور بازگشتی برای تمام همسایه‌های آن 
  نیز  
  DFS
  را فراخوانی می‌کنیم 
  و
   سپس مقدار این گره را
   در استک وارد می‌کنیم.

   حال می‌توانیم اعضای استک را نوبتی بیرون بیاوریم
   که نشان دهنده ترتیب اعداد از کوچک به بزرگ می‌باشد
   .


   \paragraph{تحلیل زمانی}
   ساختن و پیمایش گراف در زمان ثابت انجام می‌شود.
    ساختن و پیمایش درخت ترای نیز در زمان
    تعداد کل حروف تمام کلمات
    که برابر با مجموع طول آن‌ها 
    (K) 
    انجام می‌شود.
    و برای هر گره ترای نیز باید 
    حداکثر
    ۲۶ 
    فرزند را 
    در ۲۷ 
    عملیات مقایسه کنیم 
    (یال متناظر در گراف اضافه کنیم)
    که این ضریبی برای هزینه پیمایش گره ترای می‌شود
    $(O(27K) = O(K))$

    در نتیجه مرتبه زمانی الگوریتم از 
    $O(K)$
    خواهد بود
    .


% گرافی جهت‌دار با ۲۶ راس (هر راس نماینده یک حرف) می‌سازیم.
% کلمات مجاور را دو به دو و به ترتیب مقایسه می‌کنیم و در هر جفت٫ اولین حرفی که از چپ یکسان ندارند نشان دهنده یک نامساوی هست که می‌توانیم در گرافمان به شکل یال از حرف کوچک‌تر به بزرگ‌تر نمایش می‌دهیم. 

% در نهایت توپولوژیکال سورت گراف را در می‌آوریم.