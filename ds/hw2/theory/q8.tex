1-
بر روی عضو اول هر دو لیست یک اشاره‌گر در نظر بگیرید. در هر مرحله از اجرای الگوریتم مقادیری که این دو به آن‌‌ها اشاره می‌کنند را با هم مقایسه می‌کنیم و هر کدام که بزرگ تر بود اشاره‌گرش را به محل جدید می‌بریم (یک واحد به راست).
هرگاه یکی از اشاره‌گر ها به انتها رسید تمام اعضای باقی مانده لیست دیگر را پشت هم می‌نویسیم.

بدترین حالت وقتی رخ می‌دهد که هر دو اشاره‌گر در یک نوبت به انتها برسند.
یعنی 
$i = n-1$
و 
$j = n$
.

در هر دور از اجرای الگوریتم تا وقتی که هیچ کدام از اشاره‌گر ها به انتها نرسیده است باید برای تشخیص عضوی که باید در آرایه جدید بنویسیم یک مقایسه انجام بدهیم. این کار تا وقتی انجام می‌شود که بالاخره یکی از اشاره‌گر ها به انتها برسد. سپس هرچه باقی مانده چیده می‌شود.
در بدترین حالت تنها یک عضو (عضو اخر آرایه دیگر) است که بدون نیاز به مقایسه گذاشته می‌شود. به عبارتی
$2n-1$
مقایسه انجام شده است.

سودوکد الگوریتم مطرح شده در زیر آمده است.

\begin{latin}
\begin{codebox}
	\Procname{$\proc{merge}(A, B, n)$}
	\li $i,j,x$ : int = 0
	\li B : List[int] of size $2n$
	
	\li \While $i<n$ or $j<n$ \Then
	\li \If $i = n$ \Then
		\li B[x] = A[j]
		\li j = j+1
	\li \Else \If $j = n$
		\li B[x] = A[i]
		\li i = i+1
	\li \Else \If A[i] < A[j]
		\li B[x] = A[i]
		\li i = i + 1
	\li \Else
		\li B[x] = A[j]
		\li j = j+1
	\End
	\li x = x+1
	\End
	
\end{codebox}
\end{latin}
\newpage
2-
برای ادغام کردن $k$ لیست کافی است آن‌ها را دو به دو با هم ادغام کنیم. سپس لیست‌های جدید را دوباره با هم دو به دو ادغام کنیم تا وقتی که تنها یک لیست داشته باشیم. 
%(اگر k فرد باشد با ایجاد اندکی تغییر در الگوریتم می‌توان دو لیست با اندازه های غیر همسان هم ادغام کرد)

اگر k زوج باشد مرتبه زمانی الگوریتم مطرح شده به شکل زیر خواهد بود:
\begin{equation*}
	T(nk) = T(nk/2) + O(2 \frac{nk}{2}-1)
\end{equation*}

%اگر k فرد باشد برای راحتی کار تعداد لیست ها را k+1 
%در نظر می‌گیریم

رابطه بالا از آن‌جا ناشی می‌شود که الگوریتم ما در عمل مانند این است که خود k دسته را ابتدا دو گروه کنیم و این الگوریتم را بر روی هر گروه اعمال کنیم و سپس دو ابرلیستی که تشکیل می‌شود را ادغام کنیم.

بدون ایجاد اشکال در جواب می‌توانیم فرض کنیم که k به شکل $2^m$
است. اگر این چنین نباشد 
$(2^{m-1} < k < 2^m)$
کافی است که 
$2^m - k$
لیست با تعداد $n$ 
عضو با مقدار مثلا منفی بی‌نهایت اضافه کنیم و در نهایت که به پاسخ رسیدیم تمام این عضوهای زائد را از چپ حذف کنیم (در $O(nk)$) 

و محاسبه می‌شود:
\begin{equation*}
	T(nk) = O(nk\cdot log(nk))
\end{equation*}

3-
فرض کنیم زمان آن قابل کاهش باشد.
به عبارتی 
$T(nk) = o(nk\cdot log(nk))$
.

کافی است قرار دهیم
$n= 1$
.
خواهیم داشت:
\begin{equation*}
	T(k) = o(k \cdot log k)
\end{equation*}

این به این معنا است ما می‌توانیم برای مرتب کردن 
$n$ 
عدد به این شکل عمل کنیم که در 
$O(n)$
هر عدد را در یک لیست خالی قرار دهیم و سپس این $n$ لیست بدیهتا مرتب را با هم در 
$ o(nlogn)$
ادغام کنیم.
در حالی که می‌دانیم همچین چیزی نمی‌تواند ممکن باشد که الگوریتم سورت با زمان قطعی کمتر از $O(n log n)$ 
داشت 	پس فرض غلط است.