\proof
برهان خلف

فرض کنیم این‌گونه نباشد. یعنی بتوان نزدیک‌ترین عنصر آرایه 
$n$
عضوی 
$A$
به مقدار 
$x$
را در زمان 
$o(logn)$
پیدا کرد
.

آن‌گاه می‌توان الگوریتم زیر را برای مرتب کردن اعداد ارائه داد:
\lr{
\begin{codebox}
	\Procname{$\proc{sort}(A, n)$}
	\li B[n]
	\li \Comment find index of minimum and maximum
	\li min = 0
	\li max = 0
	\li \For i=0 to n \Comment exclusive \Then
	\li \If A[i] < A[min] \Then 
	\li min = i
	\End
	\li \If A[i] > A[max] \Then 
	\li max = i
	\End
	\End
	\li B[0] = A[min]
	\li \For i=1 to n \Then
	\li	x = nearest(B[i-1]) \Comment index of nearest item
	\li	B[i] = A[x]
	\li	A[x] = A[max]
	\End
	\li \Return B
	\End
\end{codebox}
}

این الگوریتم از دو بخش پیدا کردن مینیمم و ماکسیمم (در زمان خطی) و پیدا کردن نزدیک‌ترین عنصر هر عدد (در زمان 
$o(logn)$
)
است.
اردر این الگوریتم
برابر است با
\begin{equation*}
	O(n) + n * o(logn) = o(nlogn)
\end{equation*}
و داریم 
$o(n\cdot log n) < O(n\cdot log n)$
.

در حالی که می‌دانیم الگوریتم‌ مرتب‌‌سازی از مرتبه قطعی کمتر از $O(nlogn)$ وجود ندارد.

پس فرض غلط است.
یعنی هیچ الگوریتمی نیست که از 
$o(nlogn)$
باشد یا به عبارتی برای هر الگوریتم مورد نظر (برای پیدا کردن نزدیک ترین عنصر) 
داریم:

\begin{equation*}
T \in \Omega(n\cdot logn)
\end{equation*}

\newpage