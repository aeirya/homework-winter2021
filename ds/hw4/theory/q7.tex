الف)
به ازای هر عمل افزایش یک یک با کم ارزش‌ترین بیت جمع می‌شود و اگر 
carry 
داشته باشیم این جمع کردن تا رسیدن به یک صفر 
(و تبدیل آن به یک)
ادامه دارد.
استدلال می‌کنیم که هر بیتی که در این مسیر صفر می‌کنیم زمانی به دلیل افزایش‌های پیشین یک شده بود.
پس می‌توان گفت هزینه صفر کردن را با یک کردن سرشکن می‌کنیم
.
به عبارتی در هر افزایش تنها یک بیت صفر به یک تبدیل می‌شود
و باقی هزینه‌ها خرج صفر کردن یک‌ها می‌شود که آن‌ها هم هزینه‌شان با 
یک کردن‌ افزایش‌های قبلی سرشکن می‌شود٫
پس تنها از مرتبه ۱ هزینه می‌کنیم.

ب)
در این جا نیز استدلال‌های مشابهی را می‌توان کرد.
برای افزایش ابدا هزینه برای صفر کردن یک ها 
می‌کنیم و در نهایت 
منفی یک یا صفر را در مرتبه ۱ افزایش می‌دهیم.

کاهش نیز مشابه است 
(منفی یک ها را صفر می‌کنیم و در نهایت یک رقم را صفر یا منفی یک می‌کنیم
.
می‌توان استدلال کرد تمام یک هایی که صفر می‌شوند برایشان یک هزینه یک شدن در یک عمل افزایش خرج شده است
و همچنین تمام منفی یک هایی که صفر می‌شوند در یک عمل کاهش یک هزینه برای منفی یک شدن صفر خرج شده است
.
پس تمام صفر شدن یک را با یک شدن (یک) صفر در عمل افزایش سرشکن می‌کنیم 
و مشابها صفر شدن منفی یک را با منفی یک شدن صفر در عمل کاهش.

صفر شدن یک توسط کاهش و یا صفر شدن منفی یک با عمل افزایش نیز در هر بار عمل کاهش/افزایش تنها یک بار انجام می‌شود و از مرتبه یک است
.
در نهایت مرتبه زمانی الگوریتم ما به طور سرشکن از مرتبه 
1 
است.